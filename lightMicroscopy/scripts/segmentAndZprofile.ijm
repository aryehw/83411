/*
 * This script finds fluorescent beads in an image stack, and then measures the average fluorescence of the beads throughout the stack. 
 * 	Input: a stack that contains a set of images of  identical objects acquired under different conditions, which we wish to compare.
 *  Outputs: 1. A plot of the average intensity of the objects versus the stack position of each frame. 
 *           2. A list of regions of the identified objects, in the regio of interest (ROI) manager. 
 *           3. A table of parameters sich as size and intensity of the identified objects.
 *           
 *   The zProfile plot can be saved as a list of numbers. The x-axis is the slice number. 
 *   It is the user's responsibility to relate the slice number to whatever  unit is approriate. 
 *   For example, this code was originally written for use with an image stack in which each slice was a different 
 *   relative excitation intensity (100%, 75%, 50%, 25%, 10%, 0%) as indicated on the metal-halide illumination source.
 *   However, it could just as easily been a series of exposure times (eg, 500ms, 250ms, 100ms, 50ms, 10ms).
 *   
 *   Also, the results table that is generated by the particle analyzer can be saved, and then  used in R or Excel 
 *   or your favorite data analysis program. For example, the distribution of object sizes can be ued to determine
 *   how many beads are in the field, and how many clusters of  2,3,4,5 etc beads are present.
 *   
 *   This program assumes that the first slice is easily thresholded, but this will not be the case 
 *   if the 0% exposure is first. It would be possible to check the stack to see which slice is strongest, 
 *   but that was not done here. Instead, we assume that the stack contains the images ordered strongest to weakest.
 *   For our lab, the percent intensities are 100%, 75%, 50% 25%, 10%, 0%.
 *   
 *   [4 Feb 19] 1. script now finds the best fit line for mean bead intensity versus percent illumination.
 *   			2. Mean bead intensity and the best fit line are plotted against percent illumination.
 *   
 *   [26 May 21] 1. Improved the print formatting. Note that output is printed to the Log window.
 *   			 2. Corrected the code to leave a results table of the individual ROis open. 
 *   			    The ROI manager contains the individual ROIs.
 *   
 *   To do:	1. Prompt the user for the spatial calibration information, and incorporate it into the image. 
 *   		2. Add code to find the mean and std dev of the area of single beads.  
 *   		3. Use the information in (2) to find the distribution of clusters (by size -- number of beads/cluster).
 *         
 *  Author: 		Aryeh Weiss
 *  Last modified: 	26 May 2021
 */


run("Close All");
print("\n=======================================");
print("segmentAndZprofile: new run\n");

// prompt for the input file and open the  image
inputPath =File.openDialog("input file");
print("image path: ", inputPath);
inputTitle = File.getName(inputPath);
print("image name: ", inputTitle);
open(inputPath);
inputTitle = getTitle();	// save the image title in a variable

// remove overlay if the image was saved with an overlay
run("Remove Overlay");

// remove any calibration that came with the image -- work in pixel units
// this should be changed to allow for work in calibrated units.
run("Properties...", "unit=pixel pixel_width=1 pixel_height=1 voxel_depth=1.0000000");

// confirm that the change was made
Stack.getUnits(unitX, unitY, unitZ, unitTime, unitValue);
print("Units: X="+unitX+" ; Y="+unitY+" ; Z="+unitZ+" ; Time="+unitTime+" ; Value="+unitValue);

if (unitX != "pixel" || unitY != "pixel" || unitZ != "pixel") {
	exit("Setting units did not work");
}


getDimensions(width, height, channels, slices, frames);
print("width = ", width, " ; height = ", height, " ; number of channels =", channels, " ; number of slices =", slices, " ; number of frames =", frames);

if ( slices * frames < 2) {
	exit("This program expects an image stack");
}


setSlice(1); 	// segment the first slice.
// run the autothreshold command, using the Otsu method.
setAutoThreshold("Otsu dark");

// set up a bunch of parameters we may want to measure
run("Set Measurements...", "area mean standard min centroid center bounding fit shape integrated redirect=None decimal=3");

// Just in case an ROI was selected, make sure it is deselected so that we work on the entire image.
run("Select None");

// Use the particle analyzer to find the objects that are above the threshold
run("Analyze Particles...", "size=10-Infinity  display exclude clear summarize add slice");

// select the input image and clear the overlay that show the  threshold
selectImage(inputTitle);
resetThreshold();
roiManager("Show None");

// combine all of the ROIs into one ROI that includes all of the detected objects
roiManager("Combine");
// add the composite ROI hat was produced into the ROI manager
// it will be added to the bottom of the list. 
roiManager("Add");

// We want this to work on different images, so we cannot know ahead of time how many abjects will be found.
// Therefore, we have the ROI Manager tell us how many objects are in the list.
count = roiManager("count");
// There are a number of windows open, so it is good practice to make sure that the input image the active window
selectImage(inputTitle);

// select the ROI at the bottom of the ROI list in the ROI Manager. The index is zero-based, so we select the index "count-1"
roiManager("Select", count-1);

IJ.renameResults("detailed results");

// The following command computes that average intensity of the selected ROI (which in our case is the composite of all objects)
// for each slice in the stack.
run("Plot Z-axis Profile");

Plot.getValues(xpoints, ypoints);
Plot.showValues();

Array.reverse(ypoints);	// program assumes that the input was ordered strongest to weakest illumination
excitationLevels = newArray(0,10,25,50,75,100); // percent of full intensity available with the Prior Lumen 200.

// do the fit and recover the offset, slope and R squared.
Fit.doFit("Straight line", excitationLevels, ypoints);
offset = Fit.p(0);
slope = Fit.p(1);
rSqr = Fit.rSquared;
print("\nCurve fit parameters: slope=", slope, " ; offset=", offset," ; r squared=", rSqr, "\n");


// the rest of this code sets up the plot.
Plot.create("MEAN BEAD INTENSITY", "PERCENT ILLUMINATION", "MEAN GRAY LEVEL");
Plot.setLineWidth(2);
Plot.setColor("red", "red");
Plot.add("triangle", excitationLevels, ypoints);
Plot.setLineWidth(1);
Plot.setColor("black");
Plot.drawLine(excitationLevels[0], Fit.f(excitationLevels[0]),excitationLevels[excitationLevels.length - 1], Fit.f(excitationLevels[excitationLevels.length - 1])) ;
Plot.setColor("blue");
Plot.addText("y = a+bx", 0.05, 0.1);
Plot.addText("a = "+d2s(offset,0), 0.05, 0.15);
Plot.addText("b = "+d2s(slope,2), 0.05, 0.2);
Plot.addText("R squared = "+d2s(rSqr, 4), 0.05, 0.25);

Plot.show();
Plot.getValues(xpoints, ypoints);
Plot.showValues();

print("segmentAndZprofile: end of run");
print("=======================================\n");